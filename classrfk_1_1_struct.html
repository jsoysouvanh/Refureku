<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Refureku: rfk::Struct Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rfk-compact-logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Refureku<span id="projectnumber">&#160;v2.0.2</span>
   </div>
   <div id="projectbrief">C++17 runtime reflection library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classrfk_1_1_struct.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classrfk_1_1_struct-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rfk::Struct Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for rfk::Struct:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrfk_1_1_struct.png" usemap="#rfk::Struct_map" alt=""/>
  <map id="rfk::Struct_map" name="rfk::Struct_map">
<area href="classrfk_1_1_archetype.html" alt="rfk::Archetype" shape="rect" coords="95,56,275,80"/>
<area href="classrfk_1_1_entity.html" alt="rfk::Entity" shape="rect" coords="95,0,275,24"/>
<area href="classrfk_1_1_class_template.html" alt="rfk::ClassTemplate" shape="rect" coords="0,168,180,192"/>
<area href="classrfk_1_1_class_template_instantiation.html" alt="rfk::ClassTemplateInstantiation" shape="rect" coords="190,168,370,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aae9af374253e964ff6e28b082ab21ad2"><td class="memItemLeft" align="right" valign="top"><a id="aae9af374253e964ff6e28b082ab21ad2" name="aae9af374253e964ff6e28b082ab21ad2"></a>
REFUREKU_API&#160;</td><td class="memItemRight" valign="bottom"><b>Struct</b> (char const *name, std::size_t id, std::size_t memorySize, bool isClass) noexcept</td></tr>
<tr class="separator:aae9af374253e964ff6e28b082ab21ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6876deb4f46c1b385e4bf3efbcf5ab"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename... ArgTypes&gt; </td></tr>
<tr class="memitem:a7d6876deb4f46c1b385e4bf3efbcf5ab"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD rfk::SharedPtr&lt; ReturnType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a7d6876deb4f46c1b385e4bf3efbcf5ab">makeSharedInstance</a> (ArgTypes &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a7d6876deb4f46c1b385e4bf3efbcf5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an instance of the class represented by this archetype with the matching instantiator. One can add new instantiators to any class by using the Instantiator method property.  <a href="classrfk_1_1_struct.html#a7d6876deb4f46c1b385e4bf3efbcf5ab">More...</a><br /></td></tr>
<tr class="separator:a7d6876deb4f46c1b385e4bf3efbcf5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65287e5a98b114a31dd001e17aeb579d"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_struct.html">Struct</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a65287e5a98b114a31dd001e17aeb579d">getDirectSubclasses</a> () const noexcept</td></tr>
<tr class="memdesc:a65287e5a98b114a31dd001e17aeb579d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the list of all direct reflected subclasses of this struct. Direct subclasses are computed by iterating over all subclasses (direct or not), so this method might have a heavy performance cost on big class hierarchies.  <a href="classrfk_1_1_struct.html#a65287e5a98b114a31dd001e17aeb579d">More...</a><br /></td></tr>
<tr class="separator:a65287e5a98b114a31dd001e17aeb579d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6eb7c1b46e83d9c95d2409d5d6748be"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#af6eb7c1b46e83d9c95d2409d5d6748be">isSubclassOf</a> (<a class="el" href="classrfk_1_1_struct.html">Struct</a> const &amp;archetype) const noexcept</td></tr>
<tr class="memdesc:af6eb7c1b46e83d9c95d2409d5d6748be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this struct is a subclass of another struct/class.  <a href="classrfk_1_1_struct.html#af6eb7c1b46e83d9c95d2409d5d6748be">More...</a><br /></td></tr>
<tr class="separator:af6eb7c1b46e83d9c95d2409d5d6748be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828bb3de68e93f800db16a2719da96f0"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a828bb3de68e93f800db16a2719da96f0">isBaseOf</a> (<a class="el" href="classrfk_1_1_struct.html">Struct</a> const &amp;archetype) const noexcept</td></tr>
<tr class="memdesc:a828bb3de68e93f800db16a2719da96f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this struct is a base class of another struct/class.  <a href="classrfk_1_1_struct.html#a828bb3de68e93f800db16a2719da96f0">More...</a><br /></td></tr>
<tr class="separator:a828bb3de68e93f800db16a2719da96f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1905c39ae41357374ac73750335a8615"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_parent_struct.html">ParentStruct</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a1905c39ae41357374ac73750335a8615">getDirectParentAt</a> (std::size_t index) const noexcept</td></tr>
<tr class="memdesc:a1905c39ae41357374ac73750335a8615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index'th direct parent of this struct. If index is greater or equal to <a class="el" href="classrfk_1_1_struct.html#a02881b8149965c6e52c78f13e7536335" title="Get the number of reflected direct parents this struct is inheriting from.">getDirectParentsCount()</a>, the behaviour is undefined.  <a href="classrfk_1_1_struct.html#a1905c39ae41357374ac73750335a8615">More...</a><br /></td></tr>
<tr class="separator:a1905c39ae41357374ac73750335a8615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02881b8149965c6e52c78f13e7536335"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a02881b8149965c6e52c78f13e7536335">getDirectParentsCount</a> () const noexcept</td></tr>
<tr class="memdesc:a02881b8149965c6e52c78f13e7536335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of reflected direct parents this struct is inheriting from.  <a href="classrfk_1_1_struct.html#a02881b8149965c6e52c78f13e7536335">More...</a><br /></td></tr>
<tr class="separator:a02881b8149965c6e52c78f13e7536335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a2cca3c796d3f2884429158c7c2a1c"><td class="memItemLeft" align="right" valign="top">REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a61a2cca3c796d3f2884429158c7c2a1c">foreachDirectParent</a> (<a class="el" href="namespacerfk.html#aa71b489feb1ea31e5077d0807dc11535">Visitor</a>&lt; <a class="el" href="classrfk_1_1_parent_struct.html">ParentStruct</a> &gt; visitor, void *userData) const</td></tr>
<tr class="memdesc:a61a2cca3c796d3f2884429158c7c2a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the given visitor on all direct parents of this struct.  <a href="classrfk_1_1_struct.html#a61a2cca3c796d3f2884429158c7c2a1c">More...</a><br /></td></tr>
<tr class="separator:a61a2cca3c796d3f2884429158c7c2a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39eeb792f458890d67f150fbec67439"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_struct.html">Struct</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#ab39eeb792f458890d67f150fbec67439">getNestedStructByName</a> (char const *name, EAccessSpecifier access=EAccessSpecifier::Undefined) const noexcept</td></tr>
<tr class="separator:ab39eeb792f458890d67f150fbec67439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d75ec5acebdb9fcb5f00b653f380ce"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_struct.html">Struct</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a21d75ec5acebdb9fcb5f00b653f380ce">getNestedStructByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_struct.html">Struct</a> &gt; predicate, void *userData) const</td></tr>
<tr class="memdesc:a21d75ec5acebdb9fcb5f00b653f380ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the first nested struct satisfying the provided predicate.  <a href="classrfk_1_1_struct.html#a21d75ec5acebdb9fcb5f00b653f380ce">More...</a><br /></td></tr>
<tr class="separator:a21d75ec5acebdb9fcb5f00b653f380ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed028caeaabf9b286c221ac5337280e"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_struct.html">Struct</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a4ed028caeaabf9b286c221ac5337280e">getNestedStructsByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_struct.html">Struct</a> &gt; predicate, void *userData) const</td></tr>
<tr class="memdesc:a4ed028caeaabf9b286c221ac5337280e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all nested structs satisfying the provided predicate.  <a href="classrfk_1_1_struct.html#a4ed028caeaabf9b286c221ac5337280e">More...</a><br /></td></tr>
<tr class="separator:a4ed028caeaabf9b286c221ac5337280e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd3c9660dd1c06382d29907696b9672"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_struct.html">Class</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#abbd3c9660dd1c06382d29907696b9672">getNestedClassByName</a> (char const *name, EAccessSpecifier access=EAccessSpecifier::Undefined) const noexcept</td></tr>
<tr class="separator:abbd3c9660dd1c06382d29907696b9672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c64f3941cbcabb4c672905387cf165f"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_struct.html">Class</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a9c64f3941cbcabb4c672905387cf165f">getNestedClassByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_struct.html">Class</a> &gt; predicate, void *userData) const</td></tr>
<tr class="memdesc:a9c64f3941cbcabb4c672905387cf165f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the first nested class satisfying the provided predicate.  <a href="classrfk_1_1_struct.html#a9c64f3941cbcabb4c672905387cf165f">More...</a><br /></td></tr>
<tr class="separator:a9c64f3941cbcabb4c672905387cf165f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e62f52696d41284b50d3565c215b2b2"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_struct.html">Class</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a3e62f52696d41284b50d3565c215b2b2">getNestedClassesByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_struct.html">Class</a> &gt; predicate, void *userData) const</td></tr>
<tr class="memdesc:a3e62f52696d41284b50d3565c215b2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all nested classes satisfying the provided predicate.  <a href="classrfk_1_1_struct.html#a3e62f52696d41284b50d3565c215b2b2">More...</a><br /></td></tr>
<tr class="separator:a3e62f52696d41284b50d3565c215b2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466a6c44b2c0f9d0b9f9023b6abb7efd"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_enum.html">Enum</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a466a6c44b2c0f9d0b9f9023b6abb7efd">getNestedEnumByName</a> (char const *name, EAccessSpecifier access=EAccessSpecifier::Undefined) const noexcept</td></tr>
<tr class="separator:a466a6c44b2c0f9d0b9f9023b6abb7efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c1313fbcc530254fd829becda1f055"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_enum.html">Enum</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a16c1313fbcc530254fd829becda1f055">getNestedEnumByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_enum.html">Enum</a> &gt; predicate, void *userData) const</td></tr>
<tr class="memdesc:a16c1313fbcc530254fd829becda1f055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the first nested enum satisfying the provided predicate.  <a href="classrfk_1_1_struct.html#a16c1313fbcc530254fd829becda1f055">More...</a><br /></td></tr>
<tr class="separator:a16c1313fbcc530254fd829becda1f055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5816fceb3aaced61089e4e4681839fd2"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_enum.html">Enum</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a5816fceb3aaced61089e4e4681839fd2">getNestedEnumsByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_enum.html">Enum</a> &gt; predicate, void *userData) const</td></tr>
<tr class="memdesc:a5816fceb3aaced61089e4e4681839fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all nested enums satisfying the provided predicate.  <a href="classrfk_1_1_struct.html#a5816fceb3aaced61089e4e4681839fd2">More...</a><br /></td></tr>
<tr class="separator:a5816fceb3aaced61089e4e4681839fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a3baeb964fa47af493d90f4019832e"><td class="memItemLeft" align="right" valign="top">REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#af9a3baeb964fa47af493d90f4019832e">foreachNestedArchetype</a> (<a class="el" href="namespacerfk.html#aa71b489feb1ea31e5077d0807dc11535">Visitor</a>&lt; <a class="el" href="classrfk_1_1_archetype.html">Archetype</a> &gt; visitor, void *userData) const</td></tr>
<tr class="memdesc:af9a3baeb964fa47af493d90f4019832e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the given visitor on all archetypes nested in this struct.  <a href="classrfk_1_1_struct.html#af9a3baeb964fa47af493d90f4019832e">More...</a><br /></td></tr>
<tr class="separator:af9a3baeb964fa47af493d90f4019832e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cfbed4896068c4e5cace0c0f71d4e8"><td class="memItemLeft" align="right" valign="top">REFUREKU_API std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a57cfbed4896068c4e5cace0c0f71d4e8">getNestedArchetypesCount</a> () const noexcept</td></tr>
<tr class="memdesc:a57cfbed4896068c4e5cace0c0f71d4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of archetypes nested in this struct.  <a href="classrfk_1_1_struct.html#a57cfbed4896068c4e5cace0c0f71d4e8">More...</a><br /></td></tr>
<tr class="separator:a57cfbed4896068c4e5cace0c0f71d4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab92f4772fa2f26d6d80c9b3d65bc5eb"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_field.html">Field</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#aab92f4772fa2f26d6d80c9b3d65bc5eb">getFieldByName</a> (char const *name, <a class="el" href="namespacerfk.html#a4e4ebc12533da5542afa59de6d305a7a">EFieldFlags</a> minFlags=<a class="el" href="namespacerfk.html#a4e4ebc12533da5542afa59de6d305a7aa7a1920d61156abc05a60135aefe8bc67">EFieldFlags::Default</a>, bool shouldInspectInherited=false) const noexcept</td></tr>
<tr class="separator:aab92f4772fa2f26d6d80c9b3d65bc5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7aecfdf75afefda0a9488cda8089ea7"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_field.html">Field</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#ae7aecfdf75afefda0a9488cda8089ea7">getFieldByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_field.html">Field</a> &gt; predicate, void *userData, bool shouldInspectInherited=false) const</td></tr>
<tr class="memdesc:ae7aecfdf75afefda0a9488cda8089ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the first field satisfying the provided predicate.  <a href="classrfk_1_1_struct.html#ae7aecfdf75afefda0a9488cda8089ea7">More...</a><br /></td></tr>
<tr class="separator:ae7aecfdf75afefda0a9488cda8089ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e53bfc49248cba1ed673756e37b6a3e"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_field.html">Field</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a7e53bfc49248cba1ed673756e37b6a3e">getFieldsByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_field.html">Field</a> &gt; predicate, void *userData, bool shouldInspectInherited=false) const</td></tr>
<tr class="memdesc:a7e53bfc49248cba1ed673756e37b6a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all fields satisfying the provided predicate.  <a href="classrfk_1_1_struct.html#a7e53bfc49248cba1ed673756e37b6a3e">More...</a><br /></td></tr>
<tr class="separator:a7e53bfc49248cba1ed673756e37b6a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5f438c74046b36801b7a0eea1da22e"><td class="memItemLeft" align="right" valign="top">REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a3a5f438c74046b36801b7a0eea1da22e">foreachField</a> (<a class="el" href="namespacerfk.html#aa71b489feb1ea31e5077d0807dc11535">Visitor</a>&lt; <a class="el" href="classrfk_1_1_field.html">Field</a> &gt; visitor, void *userData, bool shouldInspectInherited=false) const</td></tr>
<tr class="memdesc:a3a5f438c74046b36801b7a0eea1da22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the given visitor on all fields in this struct.  <a href="classrfk_1_1_struct.html#a3a5f438c74046b36801b7a0eea1da22e">More...</a><br /></td></tr>
<tr class="separator:a3a5f438c74046b36801b7a0eea1da22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8490ee4fa52687d80cb989723f9b56c"><td class="memItemLeft" align="right" valign="top">REFUREKU_API std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#af8490ee4fa52687d80cb989723f9b56c">getFieldsCount</a> () const noexcept</td></tr>
<tr class="memdesc:af8490ee4fa52687d80cb989723f9b56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of fields (including inherited ones) in this struct.  <a href="classrfk_1_1_struct.html#af8490ee4fa52687d80cb989723f9b56c">More...</a><br /></td></tr>
<tr class="separator:af8490ee4fa52687d80cb989723f9b56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b4bf2dc3db090d1a08ac2e6a656b14"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_static_field.html">StaticField</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a26b4bf2dc3db090d1a08ac2e6a656b14">getStaticFieldByName</a> (char const *name, <a class="el" href="namespacerfk.html#a4e4ebc12533da5542afa59de6d305a7a">EFieldFlags</a> minFlags=<a class="el" href="namespacerfk.html#a4e4ebc12533da5542afa59de6d305a7aa7a1920d61156abc05a60135aefe8bc67">EFieldFlags::Default</a>, bool shouldInspectInherited=false) const noexcept</td></tr>
<tr class="separator:a26b4bf2dc3db090d1a08ac2e6a656b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab226cb9beb74e2dae36012798923a6ec"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_static_field.html">StaticField</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#ab226cb9beb74e2dae36012798923a6ec">getStaticFieldByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_static_field.html">StaticField</a> &gt; predicate, void *userData, bool shouldInspectInherited=false) const</td></tr>
<tr class="memdesc:ab226cb9beb74e2dae36012798923a6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the first static field satisfying the provided predicate.  <a href="classrfk_1_1_struct.html#ab226cb9beb74e2dae36012798923a6ec">More...</a><br /></td></tr>
<tr class="separator:ab226cb9beb74e2dae36012798923a6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad14fef2f7912e93d809f09bebe2d5a"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_static_field.html">StaticField</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a0ad14fef2f7912e93d809f09bebe2d5a">getStaticFieldsByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_static_field.html">StaticField</a> &gt; predicate, void *userData, bool shouldInspectInherited=false) const</td></tr>
<tr class="memdesc:a0ad14fef2f7912e93d809f09bebe2d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all static fields satisfying the provided predicate.  <a href="classrfk_1_1_struct.html#a0ad14fef2f7912e93d809f09bebe2d5a">More...</a><br /></td></tr>
<tr class="separator:a0ad14fef2f7912e93d809f09bebe2d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5459f36e831b96846cdec75e9fff04"><td class="memItemLeft" align="right" valign="top">REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a1f5459f36e831b96846cdec75e9fff04">foreachStaticField</a> (<a class="el" href="namespacerfk.html#aa71b489feb1ea31e5077d0807dc11535">Visitor</a>&lt; <a class="el" href="classrfk_1_1_static_field.html">StaticField</a> &gt; visitor, void *userData, bool shouldInspectInherited=false) const</td></tr>
<tr class="memdesc:a1f5459f36e831b96846cdec75e9fff04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the given visitor on all static fields in this struct.  <a href="classrfk_1_1_struct.html#a1f5459f36e831b96846cdec75e9fff04">More...</a><br /></td></tr>
<tr class="separator:a1f5459f36e831b96846cdec75e9fff04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13402bd4e93c82f79c76628aab4f6a91"><td class="memItemLeft" align="right" valign="top">REFUREKU_API std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a13402bd4e93c82f79c76628aab4f6a91">getStaticFieldsCount</a> () const noexcept</td></tr>
<tr class="memdesc:a13402bd4e93c82f79c76628aab4f6a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of static fields (including inherited ones) in this struct.  <a href="classrfk_1_1_struct.html#a13402bd4e93c82f79c76628aab4f6a91">More...</a><br /></td></tr>
<tr class="separator:a13402bd4e93c82f79c76628aab4f6a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ef4a368ca570b4cf744b83e0c58d83"><td class="memTemplParams" colspan="2">template&lt;typename MethodSignature &gt; </td></tr>
<tr class="memitem:aa7ef4a368ca570b4cf744b83e0c58d83"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD <a class="el" href="classrfk_1_1_method.html">Method</a> const *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#aa7ef4a368ca570b4cf744b83e0c58d83">getMethodByName</a> (char const *name, <a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a> minFlags=<a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a>, bool shouldInspectInherited=false) const noexcept</td></tr>
<tr class="memdesc:aa7ef4a368ca570b4cf744b83e0c58d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a method by name and signature. This template overload using signature comes handy when wanting to disambiguate 2 method overloads with and without const qualifier for example.  <a href="classrfk_1_1_struct.html#aa7ef4a368ca570b4cf744b83e0c58d83">More...</a><br /></td></tr>
<tr class="separator:aa7ef4a368ca570b4cf744b83e0c58d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b363160c455b739d48e3978616f50ba"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_method.html">Method</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a2b363160c455b739d48e3978616f50ba">getMethodByName</a> (char const *name, <a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a> minFlags=<a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a>, bool shouldInspectInherited=false) const noexcept</td></tr>
<tr class="separator:a2b363160c455b739d48e3978616f50ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8214f5b7273f2657a6fde80629810d46"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_method.html">Method</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a8214f5b7273f2657a6fde80629810d46">getMethodsByName</a> (char const *name, <a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a> minFlags=<a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a>, bool shouldInspectInherited=false) const noexcept</td></tr>
<tr class="separator:a8214f5b7273f2657a6fde80629810d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6001f7296f4808b37ad5693569f742d6"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_method.html">Method</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a6001f7296f4808b37ad5693569f742d6">getMethodByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_method.html">Method</a> &gt; predicate, void *userData, bool shouldInspectInherited=false) const</td></tr>
<tr class="memdesc:a6001f7296f4808b37ad5693569f742d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the first method satisfying the provided predicate.  <a href="classrfk_1_1_struct.html#a6001f7296f4808b37ad5693569f742d6">More...</a><br /></td></tr>
<tr class="separator:a6001f7296f4808b37ad5693569f742d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e49b9be07f1f9cf338f1440142d2189"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_method.html">Method</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a2e49b9be07f1f9cf338f1440142d2189">getMethodsByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_method.html">Method</a> &gt; predicate, void *userData, bool shouldInspectInherited=false) const</td></tr>
<tr class="memdesc:a2e49b9be07f1f9cf338f1440142d2189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all methods satisfying the provided predicate.  <a href="classrfk_1_1_struct.html#a2e49b9be07f1f9cf338f1440142d2189">More...</a><br /></td></tr>
<tr class="separator:a2e49b9be07f1f9cf338f1440142d2189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9bf893313f6166ce485b76130bdda3"><td class="memItemLeft" align="right" valign="top">REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a4b9bf893313f6166ce485b76130bdda3">foreachMethod</a> (<a class="el" href="namespacerfk.html#aa71b489feb1ea31e5077d0807dc11535">Visitor</a>&lt; <a class="el" href="classrfk_1_1_method.html">Method</a> &gt; visitor, void *userData, bool shouldInspectInherited=false) const</td></tr>
<tr class="memdesc:a4b9bf893313f6166ce485b76130bdda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the given visitor on all methods in this struct.  <a href="classrfk_1_1_struct.html#a4b9bf893313f6166ce485b76130bdda3">More...</a><br /></td></tr>
<tr class="separator:a4b9bf893313f6166ce485b76130bdda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccddb2682d5c8ed92193a9e59874962"><td class="memItemLeft" align="right" valign="top">REFUREKU_API std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a0ccddb2682d5c8ed92193a9e59874962">getMethodsCount</a> () const noexcept</td></tr>
<tr class="memdesc:a0ccddb2682d5c8ed92193a9e59874962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of methods (excluding inherited ones) in this struct.  <a href="classrfk_1_1_struct.html#a0ccddb2682d5c8ed92193a9e59874962">More...</a><br /></td></tr>
<tr class="separator:a0ccddb2682d5c8ed92193a9e59874962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbf7211d57985e9500207171d3ce9c3"><td class="memTemplParams" colspan="2">template&lt;typename StaticMethodSignature &gt; </td></tr>
<tr class="memitem:a9dbf7211d57985e9500207171d3ce9c3"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> const *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a9dbf7211d57985e9500207171d3ce9c3">getStaticMethodByName</a> (char const *name, <a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a> minFlags=<a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a>, bool shouldInspectInherited=false) const noexcept</td></tr>
<tr class="separator:a9dbf7211d57985e9500207171d3ce9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852f60f78e471db04b16c262ccfea325"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a852f60f78e471db04b16c262ccfea325">getStaticMethodByName</a> (char const *name, <a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a> minFlags=<a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a>, bool shouldInspectInherited=false) const noexcept</td></tr>
<tr class="separator:a852f60f78e471db04b16c262ccfea325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4708746f8c25519f26c4c6ca3d6e6fd2"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a4708746f8c25519f26c4c6ca3d6e6fd2">getStaticMethodsByName</a> (char const *name, <a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a> minFlags=<a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a>, bool shouldInspectInherited=false) const noexcept</td></tr>
<tr class="separator:a4708746f8c25519f26c4c6ca3d6e6fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67e66ab992f5ef87c81e521bcfa80e7"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#af67e66ab992f5ef87c81e521bcfa80e7">getStaticMethodByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> &gt; predicate, void *userData, bool shouldInspectInherited=false) const</td></tr>
<tr class="memdesc:af67e66ab992f5ef87c81e521bcfa80e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the first static method satisfying the provided predicate.  <a href="classrfk_1_1_struct.html#af67e66ab992f5ef87c81e521bcfa80e7">More...</a><br /></td></tr>
<tr class="separator:af67e66ab992f5ef87c81e521bcfa80e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f534b8362589db67366b6350c9e624"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a19f534b8362589db67366b6350c9e624">getStaticMethodsByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> &gt; predicate, void *userData, bool shouldInspectInherited=false) const</td></tr>
<tr class="memdesc:a19f534b8362589db67366b6350c9e624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all static methods satisfying the provided predicate.  <a href="classrfk_1_1_struct.html#a19f534b8362589db67366b6350c9e624">More...</a><br /></td></tr>
<tr class="separator:a19f534b8362589db67366b6350c9e624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4920c7f34bca905265d9abb7848b2467"><td class="memItemLeft" align="right" valign="top">REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a4920c7f34bca905265d9abb7848b2467">foreachStaticMethod</a> (<a class="el" href="namespacerfk.html#aa71b489feb1ea31e5077d0807dc11535">Visitor</a>&lt; <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> &gt; visitor, void *userData, bool shouldInspectInherited=false) const</td></tr>
<tr class="memdesc:a4920c7f34bca905265d9abb7848b2467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the given visitor on all static methods in this struct.  <a href="classrfk_1_1_struct.html#a4920c7f34bca905265d9abb7848b2467">More...</a><br /></td></tr>
<tr class="separator:a4920c7f34bca905265d9abb7848b2467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f64b9516424b40ef19b3e4ab746406"><td class="memItemLeft" align="right" valign="top">REFUREKU_API std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#ae0f64b9516424b40ef19b3e4ab746406">getStaticMethodsCount</a> () const noexcept</td></tr>
<tr class="memdesc:ae0f64b9516424b40ef19b3e4ab746406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of static methods (excluding inherited ones) in this struct.  <a href="classrfk_1_1_struct.html#ae0f64b9516424b40ef19b3e4ab746406">More...</a><br /></td></tr>
<tr class="separator:ae0f64b9516424b40ef19b3e4ab746406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e7487e85d4bc6e4cc80327cae8a8a8"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="namespacerfk.html#a4a556c1faf6ed33a1862ab7a976da06e">EClassKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#ab4e7487e85d4bc6e4cc80327cae8a8a8">getClassKind</a> () const noexcept</td></tr>
<tr class="memdesc:ab4e7487e85d4bc6e4cc80327cae8a8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the class kind of this instance.  <a href="classrfk_1_1_struct.html#ab4e7487e85d4bc6e4cc80327cae8a8a8">More...</a><br /></td></tr>
<tr class="separator:ab4e7487e85d4bc6e4cc80327cae8a8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacb9a1229fc7dea7a1d6d4ed64465b6"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#aeacb9a1229fc7dea7a1d6d4ed64465b6">addDirectParent</a> (<a class="el" href="classrfk_1_1_archetype.html">Archetype</a> const *archetype, EAccessSpecifier inheritanceAccess) noexcept</td></tr>
<tr class="memdesc:aeacb9a1229fc7dea7a1d6d4ed64465b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a parent to this struct if the provided archetype is a valid struct/class.  <a href="classrfk_1_1_struct.html#aeacb9a1229fc7dea7a1d6d4ed64465b6">More...</a><br /></td></tr>
<tr class="separator:aeacb9a1229fc7dea7a1d6d4ed64465b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8fce70f419e254ee205962442a4148"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a1d8fce70f419e254ee205962442a4148">setDirectParentsCapacity</a> (std::size_t capacity) noexcept</td></tr>
<tr class="memdesc:a1d8fce70f419e254ee205962442a4148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of direct parents for this struct. Useful to avoid reallocations and avoid having unused memory. If the number of direct parents is already &gt;= to the provided count, this method has no effect.  <a href="classrfk_1_1_struct.html#a1d8fce70f419e254ee205962442a4148">More...</a><br /></td></tr>
<tr class="separator:a1d8fce70f419e254ee205962442a4148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425ec1e687bfcc8cfa245b156deeddfb"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a425ec1e687bfcc8cfa245b156deeddfb">addSubclass</a> (<a class="el" href="classrfk_1_1_struct.html">Struct</a> const &amp;subclass) noexcept</td></tr>
<tr class="memdesc:a425ec1e687bfcc8cfa245b156deeddfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a subclass to this struct.  <a href="classrfk_1_1_struct.html#a425ec1e687bfcc8cfa245b156deeddfb">More...</a><br /></td></tr>
<tr class="separator:a425ec1e687bfcc8cfa245b156deeddfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c60ad0e6ee2f2cf2d2488e779f4350"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a73c60ad0e6ee2f2cf2d2488e779f4350">addNestedArchetype</a> (<a class="el" href="classrfk_1_1_archetype.html">Archetype</a> const *nestedArchetype, EAccessSpecifier accessSpecifier) noexcept</td></tr>
<tr class="memdesc:a73c60ad0e6ee2f2cf2d2488e779f4350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a nested archetype to the struct.  <a href="classrfk_1_1_struct.html#a73c60ad0e6ee2f2cf2d2488e779f4350">More...</a><br /></td></tr>
<tr class="separator:a73c60ad0e6ee2f2cf2d2488e779f4350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61d8678cf4f5dab7a5e226cbb50c2a0"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#af61d8678cf4f5dab7a5e226cbb50c2a0">setNestedArchetypesCapacity</a> (std::size_t capacity) noexcept</td></tr>
<tr class="memdesc:af61d8678cf4f5dab7a5e226cbb50c2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally pre-allocate enough memory for the provided number of nested archetypes. If the number of nested archetypes is already &gt;= to the provided capacity, this method has no effect.  <a href="classrfk_1_1_struct.html#af61d8678cf4f5dab7a5e226cbb50c2a0">More...</a><br /></td></tr>
<tr class="separator:af61d8678cf4f5dab7a5e226cbb50c2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11878bc6b0c5f8154a1d00976fe07c74"><td class="memItemLeft" align="right" valign="top">REFUREKU_API <a class="el" href="classrfk_1_1_field.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a11878bc6b0c5f8154a1d00976fe07c74">addField</a> (char const *name, std::size_t id, <a class="el" href="classrfk_1_1_type.html">Type</a> const &amp;type, <a class="el" href="namespacerfk.html#a4e4ebc12533da5542afa59de6d305a7a">EFieldFlags</a> flags, std::size_t memoryOffset, <a class="el" href="classrfk_1_1_struct.html">Struct</a> const *outerEntity) noexcept</td></tr>
<tr class="memdesc:a11878bc6b0c5f8154a1d00976fe07c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a field to the struct.  <a href="classrfk_1_1_struct.html#a11878bc6b0c5f8154a1d00976fe07c74">More...</a><br /></td></tr>
<tr class="separator:a11878bc6b0c5f8154a1d00976fe07c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c03d2b44d2e3566a6eb13679ad5c31a"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a2c03d2b44d2e3566a6eb13679ad5c31a">setFieldsCapacity</a> (std::size_t capacity) noexcept</td></tr>
<tr class="memdesc:a2c03d2b44d2e3566a6eb13679ad5c31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally pre-allocate enough memory for the provided number of fields. If the number of fields is already &gt;= to the provided capacity, this method has no effect.  <a href="classrfk_1_1_struct.html#a2c03d2b44d2e3566a6eb13679ad5c31a">More...</a><br /></td></tr>
<tr class="separator:a2c03d2b44d2e3566a6eb13679ad5c31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f04c2037d93f0789267ac1fbe8bb66"><td class="memItemLeft" align="right" valign="top">REFUREKU_API <a class="el" href="classrfk_1_1_static_field.html">StaticField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#ac5f04c2037d93f0789267ac1fbe8bb66">addStaticField</a> (char const *name, std::size_t id, <a class="el" href="classrfk_1_1_type.html">Type</a> const &amp;type, <a class="el" href="namespacerfk.html#a4e4ebc12533da5542afa59de6d305a7a">EFieldFlags</a> flags, void *fieldPtr, <a class="el" href="classrfk_1_1_struct.html">Struct</a> const *outerEntity) noexcept</td></tr>
<tr class="memdesc:ac5f04c2037d93f0789267ac1fbe8bb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a static field to the struct.  <a href="classrfk_1_1_struct.html#ac5f04c2037d93f0789267ac1fbe8bb66">More...</a><br /></td></tr>
<tr class="separator:ac5f04c2037d93f0789267ac1fbe8bb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a639e1a789f8b1a3077a95473c864f"><td class="memItemLeft" align="right" valign="top"><a id="a11a639e1a789f8b1a3077a95473c864f" name="a11a639e1a789f8b1a3077a95473c864f"></a>
REFUREKU_API <a class="el" href="classrfk_1_1_static_field.html">StaticField</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>addStaticField</b> (char const *name, std::size_t id, <a class="el" href="classrfk_1_1_type.html">Type</a> const &amp;type, <a class="el" href="namespacerfk.html#a4e4ebc12533da5542afa59de6d305a7a">EFieldFlags</a> flags, void const *fieldPtr, <a class="el" href="classrfk_1_1_struct.html">Struct</a> const *outerEntity) noexcept</td></tr>
<tr class="separator:a11a639e1a789f8b1a3077a95473c864f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1015cc505c08f8103ae2949ba43ec260"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a1015cc505c08f8103ae2949ba43ec260">setStaticFieldsCapacity</a> (std::size_t capacity) noexcept</td></tr>
<tr class="memdesc:a1015cc505c08f8103ae2949ba43ec260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally pre-allocate enough memory for the provided number of static fields. If the number of static fields is already &gt;= to the provided capacity, this method has no effect.  <a href="classrfk_1_1_struct.html#a1015cc505c08f8103ae2949ba43ec260">More...</a><br /></td></tr>
<tr class="separator:a1015cc505c08f8103ae2949ba43ec260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713323929ce32a353177141de6164f8c"><td class="memItemLeft" align="right" valign="top">REFUREKU_API <a class="el" href="classrfk_1_1_method.html">Method</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a713323929ce32a353177141de6164f8c">addMethod</a> (char const *name, std::size_t id, <a class="el" href="classrfk_1_1_type.html">Type</a> const &amp;returnType, <a class="el" href="classrfk_1_1_i_callable.html">ICallable</a> *internalMethod, <a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a> flags) noexcept</td></tr>
<tr class="memdesc:a713323929ce32a353177141de6164f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a method to the struct.  <a href="classrfk_1_1_struct.html#a713323929ce32a353177141de6164f8c">More...</a><br /></td></tr>
<tr class="separator:a713323929ce32a353177141de6164f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce49a7303e8f58648c488bd91bef141"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a9ce49a7303e8f58648c488bd91bef141">setMethodsCapacity</a> (std::size_t capacity) noexcept</td></tr>
<tr class="memdesc:a9ce49a7303e8f58648c488bd91bef141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally pre-allocate enough memory for the provided number of methods. If the number of methods is already &gt;= to the provided capacity, this method has no effect.  <a href="classrfk_1_1_struct.html#a9ce49a7303e8f58648c488bd91bef141">More...</a><br /></td></tr>
<tr class="separator:a9ce49a7303e8f58648c488bd91bef141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06977f66df71b4bd124bd486bec18416"><td class="memItemLeft" align="right" valign="top">REFUREKU_API <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#a06977f66df71b4bd124bd486bec18416">addStaticMethod</a> (char const *name, std::size_t id, <a class="el" href="classrfk_1_1_type.html">Type</a> const &amp;returnType, <a class="el" href="classrfk_1_1_i_callable.html">ICallable</a> *internalMethod, <a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a> flags) noexcept</td></tr>
<tr class="memdesc:a06977f66df71b4bd124bd486bec18416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a static method to the struct.  <a href="classrfk_1_1_struct.html#a06977f66df71b4bd124bd486bec18416">More...</a><br /></td></tr>
<tr class="separator:a06977f66df71b4bd124bd486bec18416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45d85ed3274f122e97c7faea38c7b0f"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#ab45d85ed3274f122e97c7faea38c7b0f">setStaticMethodsCapacity</a> (std::size_t capacity) noexcept</td></tr>
<tr class="memdesc:ab45d85ed3274f122e97c7faea38c7b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally pre-allocate enough memory for the provided number of static methods. If the number of static methods is already &gt;= to the provided capacity, this method has no effect.  <a href="classrfk_1_1_struct.html#ab45d85ed3274f122e97c7faea38c7b0f">More...</a><br /></td></tr>
<tr class="separator:ab45d85ed3274f122e97c7faea38c7b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf58b026e051572a14a44e715e758ef3"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_struct.html#adf58b026e051572a14a44e715e758ef3">addSharedInstantiator</a> (<a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> const &amp;instantiator) noexcept</td></tr>
<tr class="memdesc:adf58b026e051572a14a44e715e758ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new way to instantiate this struct through the makeSharedInstance method. The passed static method MUST return a rfk::SharedPtr&lt;StructType&gt;. Otherwise, the behaviour is undefined when calling <a class="el" href="classrfk_1_1_struct.html#a7d6876deb4f46c1b385e4bf3efbcf5ab" title="Make an instance of the class represented by this archetype with the matching instantiator....">Struct::makeSharedInstance</a>.  <a href="classrfk_1_1_struct.html#adf58b026e051572a14a44e715e758ef3">More...</a><br /></td></tr>
<tr class="separator:adf58b026e051572a14a44e715e758ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrfk_1_1_archetype"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrfk_1_1_archetype')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrfk_1_1_archetype.html">rfk::Archetype</a></td></tr>
<tr class="memitem:ac518f1654969b689d504bbfb8dec7231 inherit pub_methods_classrfk_1_1_archetype"><td class="memItemLeft" align="right" valign="top"><a id="ac518f1654969b689d504bbfb8dec7231" name="ac518f1654969b689d504bbfb8dec7231"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Archetype</b> (<a class="el" href="classrfk_1_1_archetype.html">Archetype</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ac518f1654969b689d504bbfb8dec7231 inherit pub_methods_classrfk_1_1_archetype"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa7392053023341b2340714c84f63bc inherit pub_methods_classrfk_1_1_archetype"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API EAccessSpecifier&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_archetype.html#a4aa7392053023341b2340714c84f63bc">getAccessSpecifier</a> () const noexcept</td></tr>
<tr class="memdesc:a4aa7392053023341b2340714c84f63bc inherit pub_methods_classrfk_1_1_archetype"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the access specifier of the archetype if it is nested in a struct or class. If the archetype is not nested in a struct or class, EAccessSpecifier::Undefined is returned.  <a href="classrfk_1_1_archetype.html#a4aa7392053023341b2340714c84f63bc">More...</a><br /></td></tr>
<tr class="separator:a4aa7392053023341b2340714c84f63bc inherit pub_methods_classrfk_1_1_archetype"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab5b2aa39904b5abaac9194fb1bdb76 inherit pub_methods_classrfk_1_1_archetype"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_archetype.html#abab5b2aa39904b5abaac9194fb1bdb76">getMemorySize</a> () const noexcept</td></tr>
<tr class="memdesc:abab5b2aa39904b5abaac9194fb1bdb76 inherit pub_methods_classrfk_1_1_archetype"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory size of an instance of the archetype, as the operator sizeof(type) would do.  <a href="classrfk_1_1_archetype.html#abab5b2aa39904b5abaac9194fb1bdb76">More...</a><br /></td></tr>
<tr class="separator:abab5b2aa39904b5abaac9194fb1bdb76 inherit pub_methods_classrfk_1_1_archetype"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7331b5d3888ea5d3e19e9d950425dc4c inherit pub_methods_classrfk_1_1_archetype"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_archetype.html#a7331b5d3888ea5d3e19e9d950425dc4c">setAccessSpecifier</a> (EAccessSpecifier access) noexcept</td></tr>
<tr class="memdesc:a7331b5d3888ea5d3e19e9d950425dc4c inherit pub_methods_classrfk_1_1_archetype"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the access specifier of the archetype in its outer struct/class.  <a href="classrfk_1_1_archetype.html#a7331b5d3888ea5d3e19e9d950425dc4c">More...</a><br /></td></tr>
<tr class="separator:a7331b5d3888ea5d3e19e9d950425dc4c inherit pub_methods_classrfk_1_1_archetype"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrfk_1_1_entity"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrfk_1_1_entity')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrfk_1_1_entity.html">rfk::Entity</a></td></tr>
<tr class="memitem:a092dbecc208629377670a6afc05af06d inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a092dbecc208629377670a6afc05af06d" name="a092dbecc208629377670a6afc05af06d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Entity</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> const &amp;)=delete</td></tr>
<tr class="separator:a092dbecc208629377670a6afc05af06d inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b78b5d1f76408794f38bf0f8e7310b1 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_property.html">Property</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a0b78b5d1f76408794f38bf0f8e7310b1">getPropertyAt</a> (std::size_t propertyIndex) const noexcept</td></tr>
<tr class="memdesc:a0b78b5d1f76408794f38bf0f8e7310b1 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the property at the given index. If propertyIndex is greater or equal to the properties count, the behaviour is undefined.  <a href="classrfk_1_1_entity.html#a0b78b5d1f76408794f38bf0f8e7310b1">More...</a><br /></td></tr>
<tr class="separator:a0b78b5d1f76408794f38bf0f8e7310b1 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d7085bf7604499b2240d527fced26e inherit pub_methods_classrfk_1_1_entity"><td class="memTemplParams" colspan="2">template&lt;typename PropertyType , typename  = std::enable_if_t&lt;std::is_base_of_v&lt;Property, PropertyType&gt; &amp;&amp; !std::is_same_v&lt;PropertyType, Property&gt;&gt;&gt; </td></tr>
<tr class="memitem:a05d7085bf7604499b2240d527fced26e inherit pub_methods_classrfk_1_1_entity"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD PropertyType const *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a05d7085bf7604499b2240d527fced26e">getProperty</a> (bool isChildClassValid=true) const noexcept</td></tr>
<tr class="memdesc:a05d7085bf7604499b2240d527fced26e inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a property of a given type from this entity.  <a href="classrfk_1_1_entity.html#a05d7085bf7604499b2240d527fced26e">More...</a><br /></td></tr>
<tr class="separator:a05d7085bf7604499b2240d527fced26e inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181a40d213920fc16895795829cdb2cf inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_property.html">Property</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a181a40d213920fc16895795829cdb2cf">getProperty</a> (<a class="el" href="classrfk_1_1_struct.html">Struct</a> const &amp;archetype, bool isChildClassValid=true) const noexcept</td></tr>
<tr class="memdesc:a181a40d213920fc16895795829cdb2cf inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the first property matching with the provided archetype.  <a href="classrfk_1_1_entity.html#a181a40d213920fc16895795829cdb2cf">More...</a><br /></td></tr>
<tr class="separator:a181a40d213920fc16895795829cdb2cf inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f771df5126a64199aa8de1a4c31f08b inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_property.html">Property</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a2f771df5126a64199aa8de1a4c31f08b">getPropertyByName</a> (char const *name) const noexcept</td></tr>
<tr class="memdesc:a2f771df5126a64199aa8de1a4c31f08b inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the first property named with the provided name.  <a href="classrfk_1_1_entity.html#a2f771df5126a64199aa8de1a4c31f08b">More...</a><br /></td></tr>
<tr class="separator:a2f771df5126a64199aa8de1a4c31f08b inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55b766a0ff8bcbbd3fa5da08bf48414 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_property.html">Property</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#ac55b766a0ff8bcbbd3fa5da08bf48414">getPropertyByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> &gt; predicate, void *userData) const</td></tr>
<tr class="memdesc:ac55b766a0ff8bcbbd3fa5da08bf48414 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a property matching with a predicate.  <a href="classrfk_1_1_entity.html#ac55b766a0ff8bcbbd3fa5da08bf48414">More...</a><br /></td></tr>
<tr class="separator:ac55b766a0ff8bcbbd3fa5da08bf48414 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd90b03c80098a53899794995e436b4 inherit pub_methods_classrfk_1_1_entity"><td class="memTemplParams" colspan="2">template&lt;typename PropertyType , typename  = std::enable_if_t&lt;std::is_base_of_v&lt;Property, PropertyType&gt; &amp;&amp; !std::is_same_v&lt;PropertyType, Property&gt;&gt;&gt; </td></tr>
<tr class="memitem:a7dd90b03c80098a53899794995e436b4 inherit pub_methods_classrfk_1_1_entity"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; PropertyType const * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a7dd90b03c80098a53899794995e436b4">getProperties</a> (bool isChildClassValid=true) const noexcept</td></tr>
<tr class="memdesc:a7dd90b03c80098a53899794995e436b4 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all properties matching with the provided archetype. If PropertyType uses multiple inheritance, its first inherited type must be <a class="el" href="classrfk_1_1_property.html" title="Base class to inherit from to define new properties.">rfk::Property</a> or derived.  <a href="classrfk_1_1_entity.html#a7dd90b03c80098a53899794995e436b4">More...</a><br /></td></tr>
<tr class="separator:a7dd90b03c80098a53899794995e436b4 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c329db7cd25c27f7f8840bfef57344 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#aa6c329db7cd25c27f7f8840bfef57344">getProperties</a> (<a class="el" href="classrfk_1_1_struct.html">Struct</a> const &amp;archetype, bool isChildClassValid=true) const noexcept</td></tr>
<tr class="memdesc:aa6c329db7cd25c27f7f8840bfef57344 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all properties matching with the provided archetype.  <a href="classrfk_1_1_entity.html#aa6c329db7cd25c27f7f8840bfef57344">More...</a><br /></td></tr>
<tr class="separator:aa6c329db7cd25c27f7f8840bfef57344 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b90791d4b32b69537b21744908961cf inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a3b90791d4b32b69537b21744908961cf">getPropertiesByName</a> (char const *name) const noexcept</td></tr>
<tr class="memdesc:a3b90791d4b32b69537b21744908961cf inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all properties named with the provided name.  <a href="classrfk_1_1_entity.html#a3b90791d4b32b69537b21744908961cf">More...</a><br /></td></tr>
<tr class="separator:a3b90791d4b32b69537b21744908961cf inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89aa815ce0d56d8d48f780bec404dbac inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a89aa815ce0d56d8d48f780bec404dbac">getPropertiesByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> &gt; predicate, void *userData) const</td></tr>
<tr class="memdesc:a89aa815ce0d56d8d48f780bec404dbac inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all properties matching with a predicate in this entity.  <a href="classrfk_1_1_entity.html#a89aa815ce0d56d8d48f780bec404dbac">More...</a><br /></td></tr>
<tr class="separator:a89aa815ce0d56d8d48f780bec404dbac inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3bc60196aba4e5c1ae66817a0f9f8c inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#afb3bc60196aba4e5c1ae66817a0f9f8c">getPropertiesCount</a> () const noexcept</td></tr>
<tr class="memdesc:afb3bc60196aba4e5c1ae66817a0f9f8c inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of properties attached to this entity.  <a href="classrfk_1_1_entity.html#afb3bc60196aba4e5c1ae66817a0f9f8c">More...</a><br /></td></tr>
<tr class="separator:afb3bc60196aba4e5c1ae66817a0f9f8c inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6b2baecc7c1c3a063ba12950c948ae inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a3b6b2baecc7c1c3a063ba12950c948ae">foreachProperty</a> (<a class="el" href="namespacerfk.html#aa71b489feb1ea31e5077d0807dc11535">Visitor</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> &gt; visitor, void *userData) const</td></tr>
<tr class="memdesc:a3b6b2baecc7c1c3a063ba12950c948ae inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the given visitor on all properties attached to this entity.  <a href="classrfk_1_1_entity.html#a3b6b2baecc7c1c3a063ba12950c948ae">More...</a><br /></td></tr>
<tr class="separator:a3b6b2baecc7c1c3a063ba12950c948ae inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349024a085b2807ade1f7dc12e47a15b inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a349024a085b2807ade1f7dc12e47a15b">getName</a> () const noexcept</td></tr>
<tr class="memdesc:a349024a085b2807ade1f7dc12e47a15b inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the entity.  <a href="classrfk_1_1_entity.html#a349024a085b2807ade1f7dc12e47a15b">More...</a><br /></td></tr>
<tr class="separator:a349024a085b2807ade1f7dc12e47a15b inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fca0dc8eed33bf14abb616fc99b9fcd inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a9fca0dc8eed33bf14abb616fc99b9fcd">hasSameName</a> (char const *name) const noexcept</td></tr>
<tr class="memdesc:a9fca0dc8eed33bf14abb616fc99b9fcd inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that this entity has the same name as the provided string.  <a href="classrfk_1_1_entity.html#a9fca0dc8eed33bf14abb616fc99b9fcd">More...</a><br /></td></tr>
<tr class="separator:a9fca0dc8eed33bf14abb616fc99b9fcd inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88488c7a3f458b81dda29f5ba664e6c inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#ac88488c7a3f458b81dda29f5ba664e6c">getId</a> () const noexcept</td></tr>
<tr class="memdesc:ac88488c7a3f458b81dda29f5ba664e6c inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the program-unique id of the entity.  <a href="classrfk_1_1_entity.html#ac88488c7a3f458b81dda29f5ba664e6c">More...</a><br /></td></tr>
<tr class="separator:ac88488c7a3f458b81dda29f5ba664e6c inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4a1f4ec5fa498f834a1c1da7553afe inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="namespacerfk.html#af958ab385009c79cc3a27e9b3183c5d5">EEntityKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#afd4a1f4ec5fa498f834a1c1da7553afe">getKind</a> () const noexcept</td></tr>
<tr class="memdesc:afd4a1f4ec5fa498f834a1c1da7553afe inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the kind of the entity. Knowing the kind allows to safely cast to child classes. Check the EEntityKind documentation for more information.  <a href="classrfk_1_1_entity.html#afd4a1f4ec5fa498f834a1c1da7553afe">More...</a><br /></td></tr>
<tr class="separator:afd4a1f4ec5fa498f834a1c1da7553afe inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640f4b0c6a592184803c413258961511 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_entity.html">Entity</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a640f4b0c6a592184803c413258961511">getOuterEntity</a> () const noexcept</td></tr>
<tr class="memdesc:a640f4b0c6a592184803c413258961511 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the outer entity of the entity. It basically corresponds to the entity this entity was declared in from a source-code point of view. A nullptr outer entity means the entity was declared at file level.  <a href="classrfk_1_1_entity.html#a640f4b0c6a592184803c413258961511">More...</a><br /></td></tr>
<tr class="separator:a640f4b0c6a592184803c413258961511 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4089b9c11fea52e987d5975f1d8455 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#abf4089b9c11fea52e987d5975f1d8455">addProperty</a> (<a class="el" href="classrfk_1_1_property.html">Property</a> const &amp;property) noexcept</td></tr>
<tr class="memdesc:abf4089b9c11fea52e987d5975f1d8455 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a property to this entity.  <a href="classrfk_1_1_entity.html#abf4089b9c11fea52e987d5975f1d8455">More...</a><br /></td></tr>
<tr class="separator:abf4089b9c11fea52e987d5975f1d8455 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1768c2e434411991a5badc9d38956d96 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a1768c2e434411991a5badc9d38956d96">setOuterEntity</a> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> const *outerEntity) noexcept</td></tr>
<tr class="memdesc:a1768c2e434411991a5badc9d38956d96 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for the field _outerEntity.  <a href="classrfk_1_1_entity.html#a1768c2e434411991a5badc9d38956d96">More...</a><br /></td></tr>
<tr class="separator:a1768c2e434411991a5badc9d38956d96 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48595d14a255dd9d76f1f6c14acb0a0 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#ac48595d14a255dd9d76f1f6c14acb0a0">setPropertiesCapacity</a> (std::size_t capacity) noexcept</td></tr>
<tr class="memdesc:ac48595d14a255dd9d76f1f6c14acb0a0 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of properties for this entity. Useful to avoid reallocations when adding a lot of properties. If the number of properties is already &gt;= to the provided capacity, this method has no effect.  <a href="classrfk_1_1_entity.html#ac48595d14a255dd9d76f1f6c14acb0a0">More...</a><br /></td></tr>
<tr class="separator:ac48595d14a255dd9d76f1f6c14acb0a0 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b62164e710f9a5600d827932f8ef98b inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a6b62164e710f9a5600d827932f8ef98b" name="a6b62164e710f9a5600d827932f8ef98b"></a>
<a class="el" href="classrfk_1_1_entity.html">Entity</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> const &amp;)=delete</td></tr>
<tr class="separator:a6b62164e710f9a5600d827932f8ef98b inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a0f7549543c0d8102c99b8befef70d inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="ab5a0f7549543c0d8102c99b8befef70d" name="ab5a0f7549543c0d8102c99b8befef70d"></a>
<a class="el" href="classrfk_1_1_entity.html">Entity</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ab5a0f7549543c0d8102c99b8befef70d inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58eb57c553e9773b2b05a5f163561e72 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a58eb57c553e9773b2b05a5f163561e72" name="a58eb57c553e9773b2b05a5f163561e72"></a>
RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> const &amp;other) const noexcept</td></tr>
<tr class="separator:a58eb57c553e9773b2b05a5f163561e72 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96260f434f193f8f2675ba3de3bc8e05 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a96260f434f193f8f2675ba3de3bc8e05" name="a96260f434f193f8f2675ba3de3bc8e05"></a>
RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> const &amp;other) const noexcept</td></tr>
<tr class="separator:a96260f434f193f8f2675ba3de3bc8e05 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5ea77b99f9622de606bc242d4d787c9b"><td class="memItemLeft" align="right" valign="top"><a id="a5ea77b99f9622de606bc242d4d787c9b" name="a5ea77b99f9622de606bc242d4d787c9b"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>Struct</b> (char const *name, std::size_t id, std::size_t memorySize, bool isClass, <a class="el" href="namespacerfk.html#a4a556c1faf6ed33a1862ab7a976da06e">EClassKind</a> classKind) noexcept</td></tr>
<tr class="separator:a5ea77b99f9622de606bc242d4d787c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b10a04c44b2ccf0c03b4fc98b6257e"><td class="memItemLeft" align="right" valign="top"><a id="a45b10a04c44b2ccf0c03b4fc98b6257e" name="a45b10a04c44b2ccf0c03b4fc98b6257e"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>Struct</b> (StructImpl *implementation) noexcept</td></tr>
<tr class="separator:a45b10a04c44b2ccf0c03b4fc98b6257e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classrfk_1_1_archetype"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrfk_1_1_archetype')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classrfk_1_1_archetype.html">rfk::Archetype</a></td></tr>
<tr class="memitem:aa03a3117de5b6e47c6dda3cbd287008e inherit pro_methods_classrfk_1_1_archetype"><td class="memItemLeft" align="right" valign="top"><a id="aa03a3117de5b6e47c6dda3cbd287008e" name="aa03a3117de5b6e47c6dda3cbd287008e"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>Archetype</b> (ArchetypeImpl *implementation) noexcept</td></tr>
<tr class="separator:aa03a3117de5b6e47c6dda3cbd287008e inherit pro_methods_classrfk_1_1_archetype"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classrfk_1_1_entity"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrfk_1_1_entity')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classrfk_1_1_entity.html">rfk::Entity</a></td></tr>
<tr class="memitem:a502d0895419cf5420ddfffb2c9743fe2 inherit pro_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a502d0895419cf5420ddfffb2c9743fe2" name="a502d0895419cf5420ddfffb2c9743fe2"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>Entity</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> &amp;&amp;) noexcept</td></tr>
<tr class="separator:a502d0895419cf5420ddfffb2c9743fe2 inherit pro_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b757749f74869d1f5f7b8257cd40591 inherit pro_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a4b757749f74869d1f5f7b8257cd40591" name="a4b757749f74869d1f5f7b8257cd40591"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>Entity</b> (EntityImpl *implementation) noexcept</td></tr>
<tr class="separator:a4b757749f74869d1f5f7b8257cd40591 inherit pro_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeacb9a1229fc7dea7a1d6d4ed64465b6" name="aeacb9a1229fc7dea7a1d6d4ed64465b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacb9a1229fc7dea7a1d6d4ed64465b6">&#9670;&nbsp;</a></span>addDirectParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API void rfk::Struct::addDirectParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrfk_1_1_archetype.html">Archetype</a> const *&#160;</td>
          <td class="paramname"><em>archetype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccessSpecifier&#160;</td>
          <td class="paramname"><em>inheritanceAccess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a parent to this struct if the provided archetype is a valid struct/class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">archetype</td><td><a class="el" href="classrfk_1_1_archetype.html">Archetype</a> of the parent struct/class. </td></tr>
    <tr><td class="paramname">inheritanceAccess</td><td>The inheritance access for the provided parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11878bc6b0c5f8154a1d00976fe07c74" name="a11878bc6b0c5f8154a1d00976fe07c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11878bc6b0c5f8154a1d00976fe07c74">&#9670;&nbsp;</a></span>addField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API <a class="el" href="classrfk_1_1_field.html">Field</a> * rfk::Struct::addField </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrfk_1_1_type.html">Type</a> const &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4e4ebc12533da5542afa59de6d305a7a">EFieldFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>memoryOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrfk_1_1_struct.html">Struct</a> const *&#160;</td>
          <td class="paramname"><em>outerEntity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a field to the struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the field. </td></tr>
    <tr><td class="paramname">id</td><td>Unique entity id of the field. </td></tr>
    <tr><td class="paramname">type</td><td><a class="el" href="classrfk_1_1_type.html">Type</a> of the field. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="classrfk_1_1_field.html">Field</a> flags. </td></tr>
    <tr><td class="paramname">memoryOffset</td><td>Offset in bytes of the field in the owner struct (obtained from offsetof). </td></tr>
    <tr><td class="paramname">outerEntity</td><td><a class="el" href="classrfk_1_1_struct.html">Struct</a> the field was first declared in (in case of inherited field, outerEntity is the parent struct).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the added field. The pointer is made from the iterator, so is unvalidated as soon as the iterator is unvalidated. If any of the parameters is unvalid, no field is added and nullptr is returned. </dd></dl>

</div>
</div>
<a id="a713323929ce32a353177141de6164f8c" name="a713323929ce32a353177141de6164f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713323929ce32a353177141de6164f8c">&#9670;&nbsp;</a></span>addMethod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API <a class="el" href="classrfk_1_1_method.html">Method</a> * rfk::Struct::addMethod </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrfk_1_1_type.html">Type</a> const &amp;&#160;</td>
          <td class="paramname"><em>returnType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrfk_1_1_i_callable.html">ICallable</a> *&#160;</td>
          <td class="paramname"><em>internalMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a method to the struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the method. </td></tr>
    <tr><td class="paramname">id</td><td>Unique entity id of the method. </td></tr>
    <tr><td class="paramname">returnType</td><td>Return type of the method call. </td></tr>
    <tr><td class="paramname">internalMethod</td><td>Dynamically allocated <a class="el" href="classrfk_1_1_member_function.html">MemberFunction</a> storing the underlying method. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="classrfk_1_1_method.html">Method</a> flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the added method. The pointer is made from the iterator, so is unvalidated as soon as the iterator is unvalidated. If any of the parameters is unvalid, no method is added and nullptr is returned. </dd></dl>

</div>
</div>
<a id="a73c60ad0e6ee2f2cf2d2488e779f4350" name="a73c60ad0e6ee2f2cf2d2488e779f4350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c60ad0e6ee2f2cf2d2488e779f4350">&#9670;&nbsp;</a></span>addNestedArchetype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API void rfk::Struct::addNestedArchetype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrfk_1_1_archetype.html">Archetype</a> const *&#160;</td>
          <td class="paramname"><em>nestedArchetype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccessSpecifier&#160;</td>
          <td class="paramname"><em>accessSpecifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a nested archetype to the struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nestedArchetype</td><td>Nested archetype. </td></tr>
    <tr><td class="paramname">accessSpeficier</td><td>Access specifier of the nested archetype in the struct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf58b026e051572a14a44e715e758ef3" name="adf58b026e051572a14a44e715e758ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf58b026e051572a14a44e715e758ef3">&#9670;&nbsp;</a></span>addSharedInstantiator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API void rfk::Struct::addSharedInstantiator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> const &amp;&#160;</td>
          <td class="paramname"><em>instantiator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new way to instantiate this struct through the makeSharedInstance method. The passed static method MUST return a rfk::SharedPtr&lt;StructType&gt;. Otherwise, the behaviour is undefined when calling <a class="el" href="classrfk_1_1_struct.html#a7d6876deb4f46c1b385e4bf3efbcf5ab" title="Make an instance of the class represented by this archetype with the matching instantiator....">Struct::makeSharedInstance</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instantiator</td><td>Pointer to the static method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5f04c2037d93f0789267ac1fbe8bb66" name="ac5f04c2037d93f0789267ac1fbe8bb66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f04c2037d93f0789267ac1fbe8bb66">&#9670;&nbsp;</a></span>addStaticField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API <a class="el" href="classrfk_1_1_static_field.html">StaticField</a> * rfk::Struct::addStaticField </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrfk_1_1_type.html">Type</a> const &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4e4ebc12533da5542afa59de6d305a7a">EFieldFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fieldPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrfk_1_1_struct.html">Struct</a> const *&#160;</td>
          <td class="paramname"><em>outerEntity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a static field to the struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the static field. </td></tr>
    <tr><td class="paramname">id</td><td>Unique entity id of the static field. </td></tr>
    <tr><td class="paramname">type</td><td><a class="el" href="classrfk_1_1_type.html">Type</a> of the static field. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="classrfk_1_1_field.html">Field</a> flags. </td></tr>
    <tr><td class="paramname">fieldPtr</td><td>Pointer to the static field. </td></tr>
    <tr><td class="paramname">outerEntity</td><td><a class="el" href="classrfk_1_1_struct.html">Struct</a> the field was first declared in (in case of inherited field, outerEntity is the parent struct).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the added static field. The pointer is made from the iterator, so is unvalidated as soon as the iterator is unvalidated. If any of the parameters is unvalid, no static field is added and nullptr is returned. </dd></dl>

</div>
</div>
<a id="a06977f66df71b4bd124bd486bec18416" name="a06977f66df71b4bd124bd486bec18416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06977f66df71b4bd124bd486bec18416">&#9670;&nbsp;</a></span>addStaticMethod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> * rfk::Struct::addStaticMethod </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrfk_1_1_type.html">Type</a> const &amp;&#160;</td>
          <td class="paramname"><em>returnType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrfk_1_1_i_callable.html">ICallable</a> *&#160;</td>
          <td class="paramname"><em>internalMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a static method to the struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">methodName</td><td>Name of the static method. </td></tr>
    <tr><td class="paramname">id</td><td>Unique entity id of the static method. </td></tr>
    <tr><td class="paramname">returnType</td><td>Return type of the static method call. </td></tr>
    <tr><td class="paramname">internalMethod</td><td>Dynamically allocated <a class="el" href="classrfk_1_1_non_member_function.html">NonMemberFunction</a> storing the underlying static method. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="classrfk_1_1_method.html">Method</a> flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the added static method. The pointer is made from the iterator, so is unvalidated as soon as the iterator is unvalidated. If any of the parameters is unvalid, no static method is added and nullptr is returned. </dd></dl>

</div>
</div>
<a id="a425ec1e687bfcc8cfa245b156deeddfb" name="a425ec1e687bfcc8cfa245b156deeddfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425ec1e687bfcc8cfa245b156deeddfb">&#9670;&nbsp;</a></span>addSubclass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API void rfk::Struct::addSubclass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrfk_1_1_struct.html">Struct</a> const &amp;&#160;</td>
          <td class="paramname"><em>subclass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a subclass to this struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subclass</td><td>The subclass to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61a2cca3c796d3f2884429158c7c2a1c" name="a61a2cca3c796d3f2884429158c7c2a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a2cca3c796d3f2884429158c7c2a1c">&#9670;&nbsp;</a></span>foreachDirectParent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API bool rfk::Struct::foreachDirectParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#aa71b489feb1ea31e5077d0807dc11535">Visitor</a>&lt; <a class="el" href="classrfk_1_1_parent_struct.html">ParentStruct</a> &gt;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute the given visitor on all direct parents of this struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>Visitor function to call. Return false to abort the foreach loop. </td></tr>
    <tr><td class="paramname">userData</td><td>Optional user data forwarded to the visitor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last visitor result before exiting the loop. If the visitor is nullptr, return false.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided visitor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a5f438c74046b36801b7a0eea1da22e" name="a3a5f438c74046b36801b7a0eea1da22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5f438c74046b36801b7a0eea1da22e">&#9670;&nbsp;</a></span>foreachField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API bool rfk::Struct::foreachField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#aa71b489feb1ea31e5077d0807dc11535">Visitor</a>&lt; <a class="el" href="classrfk_1_1_field.html">Field</a> &gt;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute the given visitor on all fields in this struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>Visitor function to call. Return false to abort the foreach loop. </td></tr>
    <tr><td class="paramname">userData</td><td>Optional user data forwarded to the visitor. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited fields be considered as well in the search process? If false, only fields introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last visitor result before exiting the loop. If the visitor is nullptr, return false.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided visitor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b9bf893313f6166ce485b76130bdda3" name="a4b9bf893313f6166ce485b76130bdda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9bf893313f6166ce485b76130bdda3">&#9670;&nbsp;</a></span>foreachMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API bool rfk::Struct::foreachMethod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#aa71b489feb1ea31e5077d0807dc11535">Visitor</a>&lt; <a class="el" href="classrfk_1_1_method.html">Method</a> &gt;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute the given visitor on all methods in this struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>Visitor function to call. Return false to abort the foreach loop. </td></tr>
    <tr><td class="paramname">userData</td><td>Optional user data forwarded to the visitor. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should iterate on inherited methods as well?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last visitor result before exiting the loop. If the visitor is nullptr, return false.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided visitor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9a3baeb964fa47af493d90f4019832e" name="af9a3baeb964fa47af493d90f4019832e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a3baeb964fa47af493d90f4019832e">&#9670;&nbsp;</a></span>foreachNestedArchetype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API bool rfk::Struct::foreachNestedArchetype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#aa71b489feb1ea31e5077d0807dc11535">Visitor</a>&lt; <a class="el" href="classrfk_1_1_archetype.html">Archetype</a> &gt;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute the given visitor on all archetypes nested in this struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>Visitor function to call. Return false to abort the foreach loop. </td></tr>
    <tr><td class="paramname">userData</td><td>Optional user data forwarded to the visitor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last visitor result before exiting the loop. If the visitor is nullptr, return false.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided visitor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f5459f36e831b96846cdec75e9fff04" name="a1f5459f36e831b96846cdec75e9fff04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5459f36e831b96846cdec75e9fff04">&#9670;&nbsp;</a></span>foreachStaticField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API bool rfk::Struct::foreachStaticField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#aa71b489feb1ea31e5077d0807dc11535">Visitor</a>&lt; <a class="el" href="classrfk_1_1_static_field.html">StaticField</a> &gt;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute the given visitor on all static fields in this struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>Visitor function to call. Return false to abort the foreach loop. </td></tr>
    <tr><td class="paramname">userData</td><td>Optional user data forwarded to the visitor. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited static fields be considered as well in the search process? If false, only fields introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last visitor result before exiting the loop. If the visitor is nullptr, return false.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided visitor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4920c7f34bca905265d9abb7848b2467" name="a4920c7f34bca905265d9abb7848b2467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4920c7f34bca905265d9abb7848b2467">&#9670;&nbsp;</a></span>foreachStaticMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API bool rfk::Struct::foreachStaticMethod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#aa71b489feb1ea31e5077d0807dc11535">Visitor</a>&lt; <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> &gt;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute the given visitor on all static methods in this struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>Visitor function to call. Return false to abort the foreach loop. </td></tr>
    <tr><td class="paramname">userData</td><td>Optional user data forwarded to the visitor. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should iterate on inherited static methods as well?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last visitor result before exiting the loop. If the visitor is nullptr, return false.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided visitor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4e7487e85d4bc6e4cc80327cae8a8a8" name="ab4e7487e85d4bc6e4cc80327cae8a8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e7487e85d4bc6e4cc80327cae8a8a8">&#9670;&nbsp;</a></span>getClassKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="namespacerfk.html#a4a556c1faf6ed33a1862ab7a976da06e">EClassKind</a> rfk::Struct::getClassKind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the class kind of this instance. </p>
<dl class="section return"><dt>Returns</dt><dd>The class kind of this instance. </dd></dl>

</div>
</div>
<a id="a1905c39ae41357374ac73750335a8615" name="a1905c39ae41357374ac73750335a8615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1905c39ae41357374ac73750335a8615">&#9670;&nbsp;</a></span>getDirectParentAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_parent_struct.html">ParentStruct</a> const  &amp; rfk::Struct::getDirectParentAt </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index'th direct parent of this struct. If index is greater or equal to <a class="el" href="classrfk_1_1_struct.html#a02881b8149965c6e52c78f13e7536335" title="Get the number of reflected direct parents this struct is inheriting from.">getDirectParentsCount()</a>, the behaviour is undefined. </p>
<dl class="section return"><dt>Returns</dt><dd>The index'th direct parent of this struct. </dd></dl>

</div>
</div>
<a id="a02881b8149965c6e52c78f13e7536335" name="a02881b8149965c6e52c78f13e7536335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02881b8149965c6e52c78f13e7536335">&#9670;&nbsp;</a></span>getDirectParentsCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API std::size_t rfk::Struct::getDirectParentsCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of reflected direct parents this struct is inheriting from. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of direct parents this struct is inheriting from. </dd></dl>

</div>
</div>
<a id="a65287e5a98b114a31dd001e17aeb579d" name="a65287e5a98b114a31dd001e17aeb579d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65287e5a98b114a31dd001e17aeb579d">&#9670;&nbsp;</a></span>getDirectSubclasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_struct.html">Struct</a> const  * &gt; rfk::Struct::getDirectSubclasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the list of all direct reflected subclasses of this struct. Direct subclasses are computed by iterating over all subclasses (direct or not), so this method might have a heavy performance cost on big class hierarchies. </p>
<dl class="section return"><dt>Returns</dt><dd>A list of all direct reflected subclasses of this struct. </dd></dl>

</div>
</div>
<a id="aab92f4772fa2f26d6d80c9b3d65bc5eb" name="aab92f4772fa2f26d6d80c9b3d65bc5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab92f4772fa2f26d6d80c9b3d65bc5eb">&#9670;&nbsp;</a></span>getFieldByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_field.html">Field</a> const  * rfk::Struct::getFieldByName </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4e4ebc12533da5542afa59de6d305a7a">EFieldFlags</a>&#160;</td>
          <td class="paramname"><em>minFlags</em> = <code><a class="el" href="namespacerfk.html#a4e4ebc12533da5542afa59de6d305a7aa7a1920d61156abc05a60135aefe8bc67">EFieldFlags::Default</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the field to retrieve. </td></tr>
    <tr><td class="paramname">minFlags</td><td>Requirements the queried field should fulfill. Keep in mind that the returned field should contain all of the specified flags, so setting for example Public and Protected will always return nullptr. <a class="el" href="namespacerfk.html#a4e4ebc12533da5542afa59de6d305a7aa7a1920d61156abc05a60135aefe8bc67">EFieldFlags::Default</a> means no requirement, so the first field named fieldName will be returned. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited fields be considered as well in the search process? If false, only fields introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first field named fieldName fulfilling all requirements. The method returns nullptr if none was found. </dd></dl>

</div>
</div>
<a id="ae7aecfdf75afefda0a9488cda8089ea7" name="ae7aecfdf75afefda0a9488cda8089ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7aecfdf75afefda0a9488cda8089ea7">&#9670;&nbsp;</a></span>getFieldByPredicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_field.html">Field</a> const  * rfk::Struct::getFieldByPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_field.html">Field</a> &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the first field satisfying the provided predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Predicate defining a valid field. </td></tr>
    <tr><td class="paramname">userData</td><td>User data forwarded to the predicate calls. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited fields be considered as well in the search process? If false, only fields introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first found field satisfying the predicate if any, else nullptr.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided predicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e53bfc49248cba1ed673756e37b6a3e" name="a7e53bfc49248cba1ed673756e37b6a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e53bfc49248cba1ed673756e37b6a3e">&#9670;&nbsp;</a></span>getFieldsByPredicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_field.html">Field</a> const  * &gt; rfk::Struct::getFieldsByPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_field.html">Field</a> &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve all fields satisfying the provided predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Predicate defining a valid field. </td></tr>
    <tr><td class="paramname">userData</td><td>User data forwarded to the predicate calls. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited fields be considered as well in the search process? If false, only fields introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All fields satisfying the predicate.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided predicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8490ee4fa52687d80cb989723f9b56c" name="af8490ee4fa52687d80cb989723f9b56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8490ee4fa52687d80cb989723f9b56c">&#9670;&nbsp;</a></span>getFieldsCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API std::size_t rfk::Struct::getFieldsCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of fields (including inherited ones) in this struct. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of fields in this struct. </dd></dl>

</div>
</div>
<a id="aa7ef4a368ca570b4cf744b83e0c58d83" name="aa7ef4a368ca570b4cf744b83e0c58d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ef4a368ca570b4cf744b83e0c58d83">&#9670;&nbsp;</a></span>getMethodByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MethodSignature &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD <a class="el" href="classrfk_1_1_method.html">Method</a> const  * rfk::Struct::getMethodByName </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a>&#160;</td>
          <td class="paramname"><em>minFlags</em> = <code><a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a method by name and signature. This template overload using signature comes handy when wanting to disambiguate 2 method overloads with and without const qualifier for example. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the method to retrieve. </td></tr>
    <tr><td class="paramname">minFlags</td><td>Requirements the queried method should fulfill. Keep in mind that the returned method should contain all of the specified flags, so setting for example Public and Protected will always return nullptr. <a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a> means no requirement, so the first method named methodName will be returned. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited methods be considered as well in the search process? If false, only methods introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first method named methodName fulfilling all requirements, nullptr if none was found. </dd></dl>

</div>
</div>
<a id="a2b363160c455b739d48e3978616f50ba" name="a2b363160c455b739d48e3978616f50ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b363160c455b739d48e3978616f50ba">&#9670;&nbsp;</a></span>getMethodByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_method.html">Method</a> const  * rfk::Struct::getMethodByName </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a>&#160;</td>
          <td class="paramname"><em>minFlags</em> = <code><a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the method to retrieve. </td></tr>
    <tr><td class="paramname">minFlags</td><td>Requirements the queried method should fulfill. Keep in mind that the returned method should contain all of the specified flags, so setting for example Public and Protected will always return nullptr. <a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a> means no requirement, so the first method named methodName will be returned. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited methods be considered as well in the search process? If false, only methods introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first method named methodName fulfilling all requirements, nullptr if none was found. </dd></dl>

</div>
</div>
<a id="a6001f7296f4808b37ad5693569f742d6" name="a6001f7296f4808b37ad5693569f742d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6001f7296f4808b37ad5693569f742d6">&#9670;&nbsp;</a></span>getMethodByPredicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_method.html">Method</a> const  * rfk::Struct::getMethodByPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_method.html">Method</a> &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the first method satisfying the provided predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Predicate defining a valid method. </td></tr>
    <tr><td class="paramname">userData</td><td>User data forwarded to the predicate calls. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited methods be considered as well in the search process? If false, only methods introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first found method satisfying the predicate if any, else nullptr.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided predicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8214f5b7273f2657a6fde80629810d46" name="a8214f5b7273f2657a6fde80629810d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8214f5b7273f2657a6fde80629810d46">&#9670;&nbsp;</a></span>getMethodsByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_method.html">Method</a> const  * &gt; rfk::Struct::getMethodsByName </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a>&#160;</td>
          <td class="paramname"><em>minFlags</em> = <code><a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the methods to retrieve. </td></tr>
    <tr><td class="paramname">minFlags</td><td>Requirements the queried methods should fulfill. Keep in mind that the returned methods should contain all of the specified flags, so setting for example Public and Protected will always return an empty vector. <a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a> means no requirement, so all methods named methodName will be returned. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited methods be considered as well in the search process? If false, only methods introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of all methods named methodName fulfilling all requirements. </dd></dl>

</div>
</div>
<a id="a2e49b9be07f1f9cf338f1440142d2189" name="a2e49b9be07f1f9cf338f1440142d2189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e49b9be07f1f9cf338f1440142d2189">&#9670;&nbsp;</a></span>getMethodsByPredicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_method.html">Method</a> const  * &gt; rfk::Struct::getMethodsByPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_method.html">Method</a> &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve all methods satisfying the provided predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Predicate defining a valid method. </td></tr>
    <tr><td class="paramname">userData</td><td>User data forwarded to the predicate calls. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited methods be considered as well in the search process? If false, only methods introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All methods satisfying the predicate.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided predicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ccddb2682d5c8ed92193a9e59874962" name="a0ccddb2682d5c8ed92193a9e59874962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccddb2682d5c8ed92193a9e59874962">&#9670;&nbsp;</a></span>getMethodsCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API std::size_t rfk::Struct::getMethodsCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of methods (excluding inherited ones) in this struct. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of methods in this struct. </dd></dl>

</div>
</div>
<a id="a57cfbed4896068c4e5cace0c0f71d4e8" name="a57cfbed4896068c4e5cace0c0f71d4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cfbed4896068c4e5cace0c0f71d4e8">&#9670;&nbsp;</a></span>getNestedArchetypesCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API std::size_t rfk::Struct::getNestedArchetypesCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of archetypes nested in this struct. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of archetypes nested in this struct. </dd></dl>

</div>
</div>
<a id="abbd3c9660dd1c06382d29907696b9672" name="abbd3c9660dd1c06382d29907696b9672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd3c9660dd1c06382d29907696b9672">&#9670;&nbsp;</a></span>getNestedClassByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_struct.html">Class</a> const  * rfk::Struct::getNestedClassByName </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccessSpecifier&#160;</td>
          <td class="paramname"><em>access</em> = <code>EAccessSpecifier::Undefined</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">className</td><td>Name of the nested class to look for. </td></tr>
    <tr><td class="paramname">access</td><td>Access specifier of the nested class in this struct. Use EAccessSpecifier::Undefined if it doesn't matter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The found nested class if any, else nullptr. </dd></dl>

</div>
</div>
<a id="a9c64f3941cbcabb4c672905387cf165f" name="a9c64f3941cbcabb4c672905387cf165f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c64f3941cbcabb4c672905387cf165f">&#9670;&nbsp;</a></span>getNestedClassByPredicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_struct.html">Class</a> const  * rfk::Struct::getNestedClassByPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_struct.html">Class</a> &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the first nested class satisfying the provided predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Predicate defining a valid nested class. </td></tr>
    <tr><td class="paramname">userData</td><td>User data forwarded to the predicate calls.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first found nested class satisfying the predicate if any, else nullptr.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided predicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e62f52696d41284b50d3565c215b2b2" name="a3e62f52696d41284b50d3565c215b2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e62f52696d41284b50d3565c215b2b2">&#9670;&nbsp;</a></span>getNestedClassesByPredicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_struct.html">Class</a> const  * &gt; rfk::Struct::getNestedClassesByPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_struct.html">Class</a> &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve all nested classes satisfying the provided predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Predicate defining a valid nested class. </td></tr>
    <tr><td class="paramname">userData</td><td>User data forwarded to the predicate calls.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All nested classes satisfying the predicate.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided predicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a466a6c44b2c0f9d0b9f9023b6abb7efd" name="a466a6c44b2c0f9d0b9f9023b6abb7efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466a6c44b2c0f9d0b9f9023b6abb7efd">&#9670;&nbsp;</a></span>getNestedEnumByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_enum.html">Enum</a> const  * rfk::Struct::getNestedEnumByName </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccessSpecifier&#160;</td>
          <td class="paramname"><em>access</em> = <code>EAccessSpecifier::Undefined</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumName</td><td>Name of the nested enum to look for. </td></tr>
    <tr><td class="paramname">access</td><td>Access specifier of the nested enum in this struct. Use EAccessSpecifier::Undefined if it doesn't matter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The found nested class if any, else nullptr. </dd></dl>

</div>
</div>
<a id="a16c1313fbcc530254fd829becda1f055" name="a16c1313fbcc530254fd829becda1f055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c1313fbcc530254fd829becda1f055">&#9670;&nbsp;</a></span>getNestedEnumByPredicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_enum.html">Enum</a> const  * rfk::Struct::getNestedEnumByPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_enum.html">Enum</a> &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the first nested enum satisfying the provided predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Predicate defining a valid nested enum. </td></tr>
    <tr><td class="paramname">userData</td><td>User data forwarded to the predicate calls.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first found nested enum satisfying the predicate if any, else nullptr.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided predicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5816fceb3aaced61089e4e4681839fd2" name="a5816fceb3aaced61089e4e4681839fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5816fceb3aaced61089e4e4681839fd2">&#9670;&nbsp;</a></span>getNestedEnumsByPredicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_enum.html">Enum</a> const  * &gt; rfk::Struct::getNestedEnumsByPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_enum.html">Enum</a> &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve all nested enums satisfying the provided predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Predicate defining a valid nested enum. </td></tr>
    <tr><td class="paramname">userData</td><td>User data forwarded to the predicate calls.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All nested enums satisfying the predicate.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided predicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab39eeb792f458890d67f150fbec67439" name="ab39eeb792f458890d67f150fbec67439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39eeb792f458890d67f150fbec67439">&#9670;&nbsp;</a></span>getNestedStructByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_struct.html">Struct</a> const  * rfk::Struct::getNestedStructByName </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccessSpecifier&#160;</td>
          <td class="paramname"><em>access</em> = <code>EAccessSpecifier::Undefined</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structName</td><td>Name of the nested struct to look for. </td></tr>
    <tr><td class="paramname">access</td><td>Access specifier of the nested struct in this struct. Use EAccessSpecifier::Undefined if it doesn't matter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The found nested struct if any, else nullptr. </dd></dl>

</div>
</div>
<a id="a21d75ec5acebdb9fcb5f00b653f380ce" name="a21d75ec5acebdb9fcb5f00b653f380ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d75ec5acebdb9fcb5f00b653f380ce">&#9670;&nbsp;</a></span>getNestedStructByPredicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_struct.html">Struct</a> const  * rfk::Struct::getNestedStructByPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_struct.html">Struct</a> &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the first nested struct satisfying the provided predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Predicate defining a valid nested struct. </td></tr>
    <tr><td class="paramname">userData</td><td>User data forwarded to the predicate calls.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first found nested struct satisfying the predicate if any, else nullptr.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided predicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ed028caeaabf9b286c221ac5337280e" name="a4ed028caeaabf9b286c221ac5337280e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed028caeaabf9b286c221ac5337280e">&#9670;&nbsp;</a></span>getNestedStructsByPredicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_struct.html">Struct</a> const  * &gt; rfk::Struct::getNestedStructsByPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_struct.html">Struct</a> &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve all nested structs satisfying the provided predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Predicate defining a valid nested struct. </td></tr>
    <tr><td class="paramname">userData</td><td>User data forwarded to the predicate calls.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All nested structs satisfying the predicate.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided predicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26b4bf2dc3db090d1a08ac2e6a656b14" name="a26b4bf2dc3db090d1a08ac2e6a656b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b4bf2dc3db090d1a08ac2e6a656b14">&#9670;&nbsp;</a></span>getStaticFieldByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_static_field.html">StaticField</a> const  * rfk::Struct::getStaticFieldByName </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4e4ebc12533da5542afa59de6d305a7a">EFieldFlags</a>&#160;</td>
          <td class="paramname"><em>minFlags</em> = <code><a class="el" href="namespacerfk.html#a4e4ebc12533da5542afa59de6d305a7aa7a1920d61156abc05a60135aefe8bc67">EFieldFlags::Default</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the static field to retrieve. </td></tr>
    <tr><td class="paramname">minFlags</td><td>Requirements the queried static field should fulfill. Keep in mind that the returned static field should contain all of the specified flags, so setting for example Public and Protected will always return nullptr. <a class="el" href="namespacerfk.html#a4e4ebc12533da5542afa59de6d305a7aa7a1920d61156abc05a60135aefe8bc67">EFieldFlags::Default</a> means no requirement, so the first static field named fieldName will be returned. Note: It doesn't matter whether you set the Static flag or not as this method is designed to return static fields only. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited static fields be considered as well in the search process? If false, only static fields introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first static field named fieldName fulfilling all requirements. The method returns nullptr if none was found. </dd></dl>

</div>
</div>
<a id="ab226cb9beb74e2dae36012798923a6ec" name="ab226cb9beb74e2dae36012798923a6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab226cb9beb74e2dae36012798923a6ec">&#9670;&nbsp;</a></span>getStaticFieldByPredicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_static_field.html">StaticField</a> const  * rfk::Struct::getStaticFieldByPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_static_field.html">StaticField</a> &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the first static field satisfying the provided predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Predicate defining a valid static field. </td></tr>
    <tr><td class="paramname">userData</td><td>User data forwarded to the predicate calls. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited static fields be considered as well in the search process? If false, only static fields introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first found static field satisfying the predicate if any, else nullptr.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided predicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ad14fef2f7912e93d809f09bebe2d5a" name="a0ad14fef2f7912e93d809f09bebe2d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad14fef2f7912e93d809f09bebe2d5a">&#9670;&nbsp;</a></span>getStaticFieldsByPredicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_static_field.html">StaticField</a> const  * &gt; rfk::Struct::getStaticFieldsByPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_static_field.html">StaticField</a> &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve all static fields satisfying the provided predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Predicate defining a valid static field. </td></tr>
    <tr><td class="paramname">userData</td><td>User data forwarded to the predicate calls. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited static fields be considered as well in the search process? If false, only static fields introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All static fields satisfying the predicate.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided predicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13402bd4e93c82f79c76628aab4f6a91" name="a13402bd4e93c82f79c76628aab4f6a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13402bd4e93c82f79c76628aab4f6a91">&#9670;&nbsp;</a></span>getStaticFieldsCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API std::size_t rfk::Struct::getStaticFieldsCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of static fields (including inherited ones) in this struct. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of static fields in this struct. </dd></dl>

</div>
</div>
<a id="a9dbf7211d57985e9500207171d3ce9c3" name="a9dbf7211d57985e9500207171d3ce9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbf7211d57985e9500207171d3ce9c3">&#9670;&nbsp;</a></span>getStaticMethodByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StaticMethodSignature &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> const  * rfk::Struct::getStaticMethodByName </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a>&#160;</td>
          <td class="paramname"><em>minFlags</em> = <code><a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the static method to retrieve. </td></tr>
    <tr><td class="paramname">minFlags</td><td>Requirements the queried static method should fulfill. Keep in mind that the returned static method should contain all of the specified flags, so setting for example Public and Protected will always return nullptr. <a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a> means no requirement, so the first static method named methodName will be returned. Note: It doesn't matter whether you set the Static flag or not as this method is designed to return static methods only. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited static methods be considered as well in the search process? If false, only static methods introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first static method named methodName fulfilling all requirements, nullptr if none was found. </dd></dl>

</div>
</div>
<a id="a852f60f78e471db04b16c262ccfea325" name="a852f60f78e471db04b16c262ccfea325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852f60f78e471db04b16c262ccfea325">&#9670;&nbsp;</a></span>getStaticMethodByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> const  * rfk::Struct::getStaticMethodByName </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a>&#160;</td>
          <td class="paramname"><em>minFlags</em> = <code><a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the static method to retrieve. </td></tr>
    <tr><td class="paramname">minFlags</td><td>Requirements the queried static method should fulfill. Keep in mind that the returned static method should contain all of the specified flags, so setting for example Public and Protected will always return nullptr. <a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a> means no requirement, so the first static method named methodName will be returned. Note: It doesn't matter whether you set the Static flag or not as this method is designed to return static methods only. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited static methods be considered as well in the search process? If false, only static methods introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first static method named methodName fulfilling all requirements, nullptr if none was found. </dd></dl>

</div>
</div>
<a id="af67e66ab992f5ef87c81e521bcfa80e7" name="af67e66ab992f5ef87c81e521bcfa80e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67e66ab992f5ef87c81e521bcfa80e7">&#9670;&nbsp;</a></span>getStaticMethodByPredicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> const  * rfk::Struct::getStaticMethodByPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the first static method satisfying the provided predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Predicate defining a valid static method. </td></tr>
    <tr><td class="paramname">userData</td><td>User data forwarded to the predicate calls. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited static methods be considered as well in the search process? If false, only static methods introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first found static method satisfying the predicate if any, else nullptr.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided predicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4708746f8c25519f26c4c6ca3d6e6fd2" name="a4708746f8c25519f26c4c6ca3d6e6fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4708746f8c25519f26c4c6ca3d6e6fd2">&#9670;&nbsp;</a></span>getStaticMethodsByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> const  * &gt; rfk::Struct::getStaticMethodsByName </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a>&#160;</td>
          <td class="paramname"><em>minFlags</em> = <code><a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">methodName</td><td>Name of the static methods to retrieve. </td></tr>
    <tr><td class="paramname">minFlags</td><td>Requirements the queried static methods should fulfill. Keep in mind that the returned static methods should contain all of the specified flags, so setting for example Public and Protected will always return an empty vector. <a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6ea7a1920d61156abc05a60135aefe8bc67">EMethodFlags::Default</a> means no requirement, so all static methods named methodName will be returned. Note: It doesn't matter whether you set the Static flag or not as this method is designed to return static methods only. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited static methods be considered as well in the search process? If false, only static methods introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All static methods named methodName fulfilling all requirements. </dd></dl>

</div>
</div>
<a id="a19f534b8362589db67366b6350c9e624" name="a19f534b8362589db67366b6350c9e624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f534b8362589db67366b6350c9e624">&#9670;&nbsp;</a></span>getStaticMethodsByPredicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> const  * &gt; rfk::Struct::getStaticMethodsByPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_static_method.html">StaticMethod</a> &gt;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldInspectInherited</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve all static methods satisfying the provided predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Predicate defining a valid static method. </td></tr>
    <tr><td class="paramname">userData</td><td>User data forwarded to the predicate calls. </td></tr>
    <tr><td class="paramname">shouldInspectInherited</td><td>Should inherited static methods be considered as well in the search process? If false, only static methods introduced by this struct will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All static methods satisfying the predicate.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the provided predicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0f64b9516424b40ef19b3e4ab746406" name="ae0f64b9516424b40ef19b3e4ab746406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f64b9516424b40ef19b3e4ab746406">&#9670;&nbsp;</a></span>getStaticMethodsCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API std::size_t rfk::Struct::getStaticMethodsCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of static methods (excluding inherited ones) in this struct. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of static methods in this struct. </dd></dl>

</div>
</div>
<a id="a828bb3de68e93f800db16a2719da96f0" name="a828bb3de68e93f800db16a2719da96f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828bb3de68e93f800db16a2719da96f0">&#9670;&nbsp;</a></span>isBaseOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API bool rfk::Struct::isBaseOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrfk_1_1_struct.html">Struct</a> const &amp;&#160;</td>
          <td class="paramname"><em>archetype</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this struct is a base class of another struct/class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">archetype</td><td><a class="el" href="classrfk_1_1_archetype.html">Archetype</a> of the tested child struct/class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this struct is a base class of the provided archetype, else false. Note that if the provided archetype is the same as this struct, true is returned. </dd></dl>

</div>
</div>
<a id="af6eb7c1b46e83d9c95d2409d5d6748be" name="af6eb7c1b46e83d9c95d2409d5d6748be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6eb7c1b46e83d9c95d2409d5d6748be">&#9670;&nbsp;</a></span>isSubclassOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API bool rfk::Struct::isSubclassOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrfk_1_1_struct.html">Struct</a> const &amp;&#160;</td>
          <td class="paramname"><em>archetype</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this struct is a subclass of another struct/class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">archetype</td><td><a class="el" href="classrfk_1_1_archetype.html">Archetype</a> of the tested parent struct/class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this struct is a subclass of the provided archetype, else false. Note that if the provided archetype is the same as this struct, false is returned. </dd></dl>

</div>
</div>
<a id="a7d6876deb4f46c1b385e4bf3efbcf5ab" name="a7d6876deb4f46c1b385e4bf3efbcf5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6876deb4f46c1b385e4bf3efbcf5ab">&#9670;&nbsp;</a></span>makeSharedInstance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , typename... ArgTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD rfk::SharedPtr&lt; ReturnType &gt; rfk::Struct::makeSharedInstance </td>
          <td>(</td>
          <td class="paramtype">ArgTypes &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make an instance of the class represented by this archetype with the matching instantiator. One can add new instantiators to any class by using the Instantiator method property. </p>
<dl class="section return"><dt>Returns</dt><dd>An instance of this struct if a suitable instantiator was found, else nullptr.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown by the used instantiator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d8fce70f419e254ee205962442a4148" name="a1d8fce70f419e254ee205962442a4148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8fce70f419e254ee205962442a4148">&#9670;&nbsp;</a></span>setDirectParentsCapacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API void rfk::Struct::setDirectParentsCapacity </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the number of direct parents for this struct. Useful to avoid reallocations and avoid having unused memory. If the number of direct parents is already &gt;= to the provided count, this method has no effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The number of direct parents of this struct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c03d2b44d2e3566a6eb13679ad5c31a" name="a2c03d2b44d2e3566a6eb13679ad5c31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c03d2b44d2e3566a6eb13679ad5c31a">&#9670;&nbsp;</a></span>setFieldsCapacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API void rfk::Struct::setFieldsCapacity </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internally pre-allocate enough memory for the provided number of fields. If the number of fields is already &gt;= to the provided capacity, this method has no effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The number of fields to pre-allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ce49a7303e8f58648c488bd91bef141" name="a9ce49a7303e8f58648c488bd91bef141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce49a7303e8f58648c488bd91bef141">&#9670;&nbsp;</a></span>setMethodsCapacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API void rfk::Struct::setMethodsCapacity </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internally pre-allocate enough memory for the provided number of methods. If the number of methods is already &gt;= to the provided capacity, this method has no effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The number of methods to pre-allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af61d8678cf4f5dab7a5e226cbb50c2a0" name="af61d8678cf4f5dab7a5e226cbb50c2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61d8678cf4f5dab7a5e226cbb50c2a0">&#9670;&nbsp;</a></span>setNestedArchetypesCapacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API void rfk::Struct::setNestedArchetypesCapacity </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internally pre-allocate enough memory for the provided number of nested archetypes. If the number of nested archetypes is already &gt;= to the provided capacity, this method has no effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The number of nested archetypes to pre-allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1015cc505c08f8103ae2949ba43ec260" name="a1015cc505c08f8103ae2949ba43ec260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1015cc505c08f8103ae2949ba43ec260">&#9670;&nbsp;</a></span>setStaticFieldsCapacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API void rfk::Struct::setStaticFieldsCapacity </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internally pre-allocate enough memory for the provided number of static fields. If the number of static fields is already &gt;= to the provided capacity, this method has no effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The number of static fields to pre-allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab45d85ed3274f122e97c7faea38c7b0f" name="ab45d85ed3274f122e97c7faea38c7b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45d85ed3274f122e97c7faea38c7b0f">&#9670;&nbsp;</a></span>setStaticMethodsCapacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API void rfk::Struct::setStaticMethodsCapacity </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internally pre-allocate enough memory for the provided number of static methods. If the number of static methods is already &gt;= to the provided capacity, this method has no effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The number of static methods to pre-allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Refureku/Library/Include/Public/Refureku/TypeInfo/Archetypes/<a class="el" href="_struct_8h_source.html">Struct.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacerfk.html">rfk</a></li><li class="navelem"><a class="el" href="classrfk_1_1_struct.html">Struct</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
